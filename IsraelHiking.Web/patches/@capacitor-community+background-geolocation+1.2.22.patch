diff --git a/node_modules/@capacitor-community/background-geolocation/CapacitorCommunityBackgroundGeolocation.podspec b/node_modules/@capacitor-community/background-geolocation/CapacitorCommunityBackgroundGeolocation.podspec
index 5bbccd2..1771785 100644
--- a/node_modules/@capacitor-community/background-geolocation/CapacitorCommunityBackgroundGeolocation.podspec
+++ b/node_modules/@capacitor-community/background-geolocation/CapacitorCommunityBackgroundGeolocation.podspec
@@ -10,4 +10,5 @@
     s.source_files = 'ios/Plugin/**/*.{swift,h,m,c,cc,mm,cpp}'
     s.ios.deployment_target  = '12.0'
     s.dependency 'Capacitor'
+    s.dependency 'CocoaLumberjack/Swift'
   end
diff --git a/node_modules/@capacitor-community/background-geolocation/android/src/main/java/com/equimaps/capacitor_background_geolocation/BackgroundGeolocation.java b/node_modules/@capacitor-community/background-geolocation/android/src/main/java/com/equimaps/capacitor_background_geolocation/BackgroundGeolocation.java
index 86bd74c..974856d 100644
--- a/node_modules/@capacitor-community/background-geolocation/android/src/main/java/com/equimaps/capacitor_background_geolocation/BackgroundGeolocation.java
+++ b/node_modules/@capacitor-community/background-geolocation/android/src/main/java/com/equimaps/capacitor_background_geolocation/BackgroundGeolocation.java
@@ -286,7 +286,10 @@ public class BackgroundGeolocation extends Plugin {
     public void load() {
         super.load();
 
-        // Android O requires a Notification Channel.
+        BackgroundGeolocationService.initLogger(getContext());
+
+        // Android O requires a Notification Channel and the service must be started in the foreground.
+        Intent serviceIntent = new Intent(getContext(), BackgroundGeolocationService.class);
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
             NotificationManager manager = (NotificationManager) getContext().getSystemService(
                     Context.NOTIFICATION_SERVICE
@@ -303,10 +306,13 @@ public class BackgroundGeolocation extends Plugin {
             channel.enableVibration(false);
             channel.setSound(null, null);
             manager.createNotificationChannel(channel);
+            this.getContext().startForegroundService(serviceIntent);
+        } else {
+            this.getContext().startService(serviceIntent);
         }
 
         this.getContext().bindService(
-                new Intent(this.getContext(), BackgroundGeolocationService.class),
+                serviceIntent,
                 new ServiceConnection() {
                     @Override
                     public void onServiceConnected(ComponentName name, IBinder binder) {
@@ -328,6 +334,7 @@ public class BackgroundGeolocation extends Plugin {
 
     @Override
     protected void handleOnResume() {
+        BackgroundGeolocationService.writeToLogFile("onResume");
         if (service != null) {
             if (stoppedWithoutPermissions && hasRequiredPermissions()) {
                 service.onPermissionsGranted();
@@ -338,15 +345,18 @@ public class BackgroundGeolocation extends Plugin {
 
     @Override
     protected void handleOnPause() {
+        BackgroundGeolocationService.writeToLogFile("onPause");
         stoppedWithoutPermissions = !hasRequiredPermissions();
         super.handleOnPause();
     }
 
     @Override
     protected void handleOnDestroy() {
+        BackgroundGeolocationService.writeToLogFile("onDestroy");
         if (service != null) {
             service.stopService();
         }
+        BackgroundGeolocationService.closeLog();
         super.handleOnDestroy();
     }
 }
diff --git a/node_modules/@capacitor-community/background-geolocation/android/src/main/java/com/equimaps/capacitor_background_geolocation/BackgroundGeolocationService.java b/node_modules/@capacitor-community/background-geolocation/android/src/main/java/com/equimaps/capacitor_background_geolocation/BackgroundGeolocationService.java
index fafbb86..0a460af 100644
--- a/node_modules/@capacitor-community/background-geolocation/android/src/main/java/com/equimaps/capacitor_background_geolocation/BackgroundGeolocationService.java
+++ b/node_modules/@capacitor-community/background-geolocation/android/src/main/java/com/equimaps/capacitor_background_geolocation/BackgroundGeolocationService.java
@@ -2,29 +2,44 @@ package com.equimaps.capacitor_background_geolocation;
 
 import android.app.Notification;
 import android.app.Service;
+import android.content.Context;
 import android.content.Intent;
-import android.content.pm.ServiceInfo;
-import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
 import android.os.Binder;
-import android.os.Build;
 import android.os.IBinder;
 
-import com.getcapacitor.Logger;
-import com.google.android.gms.location.FusedLocationProviderClient;
-import com.google.android.gms.location.LocationAvailability;
-import com.google.android.gms.location.LocationCallback;
-import com.google.android.gms.location.LocationRequest;
-import com.google.android.gms.location.LocationResult;
-import com.google.android.gms.location.LocationServices;
-
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.text.SimpleDateFormat;
+import java.util.Date;
 import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.Locale;
 
 import androidx.localbroadcastmanager.content.LocalBroadcastManager;
 
+import com.getcapacitor.Logger;
+
 // A bound and started service that is promoted to a foreground service
 // (showing a persistent notification) when the first background watcher is
 // added, and demoted when the last background watcher is removed.
 public class BackgroundGeolocationService extends Service {
+
+    private static PrintWriter logWriter;
+    private static final SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", Locale.US);
+    private static final Object logLock = new Object(); // For thread safety
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        writeToLogFile("onStartCommand called");
+        return START_STICKY;
+    }
+
     static final String ACTION_BROADCAST = (
             BackgroundGeolocationService.class.getPackage().getName() + ".broadcast"
     );
@@ -33,11 +48,11 @@ public class BackgroundGeolocationService extends Service {
     // Must be unique for this application.
     private static final int NOTIFICATION_ID = 28351;
 
-    private class Watcher {
+    private static class Watcher {
         public String id;
-        public FusedLocationProviderClient client;
-        public LocationRequest locationRequest;
-        public LocationCallback locationCallback;
+        public LocationManager client;
+        public float distanceFilter;
+        public LocationListener locationCallback;
         public Notification backgroundNotification;
     }
     private HashSet<Watcher> watchers = new HashSet<Watcher>();
@@ -54,9 +69,9 @@ public class BackgroundGeolocationService extends Service {
     @Override
     public boolean onUnbind(Intent intent) {
         for (Watcher watcher : watchers) {
-            watcher.client.removeLocationUpdates(watcher.locationCallback);
+            watcher.client.removeUpdates(watcher.locationCallback);
         }
-        watchers = new HashSet<Watcher>();
+        watchers = new HashSet<>();
         stopSelf();
         return false;
     }
@@ -77,39 +92,24 @@ public class BackgroundGeolocationService extends Service {
                 Notification backgroundNotification,
                 float distanceFilter
         ) {
-            FusedLocationProviderClient client = LocationServices.getFusedLocationProviderClient(
-                    BackgroundGeolocationService.this
-            );
-            LocationRequest locationRequest = new LocationRequest();
-            locationRequest.setMaxWaitTime(1000);
-            locationRequest.setInterval(1000);
-            locationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);
-            locationRequest.setSmallestDisplacement(distanceFilter);
-
-            LocationCallback callback = new LocationCallback(){
-                @Override
-                public void onLocationResult(LocationResult locationResult) {
-                    Location location = locationResult.getLastLocation();
-                    Intent intent = new Intent(ACTION_BROADCAST);
-                    intent.putExtra("location", location);
-                    intent.putExtra("id", id);
-                    LocalBroadcastManager.getInstance(
-                            getApplicationContext()
-                    ).sendBroadcast(intent);
-                }
-                @Override
-                public void onLocationAvailability(LocationAvailability availability) {
-                    if (!availability.isLocationAvailable()) {
-                        Logger.debug("Location not available");
-                    }
-                }
+            writeToLogFile("Adding watcher " + id + " Existing watchers: " + watchers.size());
+            LocationManager locationManager = (LocationManager)getSystemService(Context.LOCATION_SERVICE);
+
+            LocationListener listener = location -> {
+                writeToLogFile("Received location: " + location);
+                Intent intent = new Intent(ACTION_BROADCAST);
+                intent.putExtra("location", location);
+                intent.putExtra("id", id);
+                LocalBroadcastManager.getInstance(
+                        getApplicationContext()
+                ).sendBroadcast(intent);
             };
 
             Watcher watcher = new Watcher();
             watcher.id = id;
-            watcher.client = client;
-            watcher.locationRequest = locationRequest;
-            watcher.locationCallback = callback;
+            watcher.client = locationManager;
+            watcher.distanceFilter = distanceFilter;
+            watcher.locationCallback = listener;
             watcher.backgroundNotification = backgroundNotification;
             watchers.add(watcher);
 
@@ -118,7 +118,9 @@ public class BackgroundGeolocationService extends Service {
             // we simply ignore the exception.
             try {
                 watcher.client.requestLocationUpdates(
-                        watcher.locationRequest,
+                        LocationManager.GPS_PROVIDER,
+                        1000,
+                        watcher.distanceFilter,
                         watcher.locationCallback,
                         null
                 );
@@ -145,31 +147,103 @@ public class BackgroundGeolocationService extends Service {
         void removeWatcher(String id) {
             for (Watcher watcher : watchers) {
                 if (watcher.id.equals(id)) {
-                    watcher.client.removeLocationUpdates(watcher.locationCallback);
+                    watcher.client.removeUpdates(watcher.locationCallback);
                     watchers.remove(watcher);
                     if (getNotification() == null) {
                         stopForeground(true);
                     }
+                    writeToLogFile("Removed watcher " + id + " Remaining watchers: " + watchers.size());
                     return;
                 }
             }
+            writeToLogFile("Couldn't find watcher " + id + " Remaining watchers: " + watchers.size());
         }
 
         void onPermissionsGranted() {
             // If permissions were granted while the app was in the background, for example in
             // the Settings app, the watchers need restarting.
             for (Watcher watcher : watchers) {
-                watcher.client.removeLocationUpdates(watcher.locationCallback);
-                watcher.client.requestLocationUpdates(
-                        watcher.locationRequest,
-                        watcher.locationCallback,
-                        null
-                );
+                watcher.client.removeUpdates(watcher.locationCallback);
+                try {
+                    watcher.client.requestLocationUpdates(
+                            LocationManager.GPS_PROVIDER,
+                            1000,
+                            watcher.distanceFilter,
+                            watcher.locationCallback,
+                            null
+                    );
+                } catch (SecurityException ignored) {
+
+                }
+
             }
         }
 
         void stopService() {
             BackgroundGeolocationService.this.stopSelf();
+            writeToLogFile("stopService called");
+        }
+    }
+
+    public static void writeToLogFile(String message) {
+        synchronized (logLock) {
+            // Ensure logger is initialized. If not, try to initialize (though load() should handle it)
+            if (logWriter == null) {
+                return;
+            }
+            logWriter.println(formatter.format(new Date()) + " | " + message);
+            logWriter.flush();
+        }
+    }
+
+    public static void initLogger(Context applicationContext) {
+        File currentLogFile = new File(applicationContext.getFilesDir(), "bg_geolocation_log.txt");
+        synchronized (logLock) {
+            try {
+                if (!currentLogFile.exists()) {
+                    logWriter = new PrintWriter(new FileWriter(currentLogFile, true));
+                    return;
+                }
+
+                int originalLineCount = 0;
+                try (BufferedReader reader = new BufferedReader(new FileReader(currentLogFile))) {
+                    while (reader.readLine() != null) {
+                        originalLineCount++;
+                    }
+                }
+
+                if (originalLineCount > 10000) {
+                    LinkedList<String> linesToKeep = new LinkedList<>();
+                    int startLineIndexToKeep = originalLineCount - 10000;
+
+                    try (BufferedReader reader = new BufferedReader(new FileReader(currentLogFile))) {
+                        String line;
+                        int currentLineIndex = 0;
+                        while ((line = reader.readLine()) != null) {
+                            if (currentLineIndex >= startLineIndexToKeep) {
+                                linesToKeep.add(line);
+                            }
+                            currentLineIndex++;
+                        }
+                    }
+
+                    try (PrintWriter writer = new PrintWriter(new FileWriter(currentLogFile, false))) {
+                        for (String line : linesToKeep) {
+                            writer.println(line);
+                        }
+                    }
+                }
+                logWriter = new PrintWriter(new FileWriter(currentLogFile, true));
+            } catch (IOException e) {
+                logWriter = null;
+            }
+        }
+    }
+
+    public static void closeLog() {
+        if (logWriter != null) {
+            logWriter.close();
+            logWriter = null;
         }
     }
 }
